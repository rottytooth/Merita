recipeParser = /*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */ function() {
    "use strict";
    function peg$subclass(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
    }
    function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") Error.captureStackTrace(this, peg$SyntaxError);
    }
    peg$subclass(peg$SyntaxError, Error);
    peg$SyntaxError.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
            literal: function(expectation) {
                return '"' + literalEscape(expectation.text) + '"';
            },
            "class": function(expectation) {
                var escapedParts = "", i;
                for(i = 0; i < expectation.parts.length; i++)escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
                return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
            },
            any: function(expectation) {
                return "any character";
            },
            end: function(expectation) {
                return "end of input";
            },
            other: function(expectation) {
                return expectation.description;
            }
        };
        function hex(ch) {
            return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
            });
        }
        function classEscape(s) {
            return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
                return "\\x0" + hex(ch);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
                return "\\x" + hex(ch);
            });
        }
        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected) {
            var descriptions = new Array(expected.length), i, j;
            for(i = 0; i < expected.length; i++)descriptions[i] = describeExpectation(expected[i]);
            descriptions.sort();
            if (descriptions.length > 0) {
                for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                    descriptions[j] = descriptions[i];
                    j++;
                }
                descriptions.length = j;
            }
            switch(descriptions.length){
                case 1:
                    return descriptions[0];
                case 2:
                    return descriptions[0] + " or " + descriptions[1];
                default:
                    return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
            }
        }
        function describeFound(found) {
            return found ? '"' + literalEscape(found) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    };
    function peg$parse(input, options) {
        options = options !== void 0 ? options : {};
        var peg$FAILED = {}, peg$startRuleFunctions = {
            Program: peg$parseProgram
        }, peg$startRuleFunction = peg$parseProgram, peg$c0 = function(t, ing, ins) {
            let code = setup;
            // if torte in title, include torte code
            if (t.toLowerCase().includes("torte")) code += shapes["torte"].code;
            for(let i = 0; i < ing.length; i++){
                let shape = "";
                let completed = false;
                let selected_shape = undefined;
                if (ing[i].food.toLowerCase().includes("worcestershire")) // alert("turned off dog");
                shapes["dog"].done = true;
                for(var key in shapes){
                    if (Object.hasOwn(shapes[key], !shapes[key].done) && ing[i].type == shapes[key].type) {
                        shape += shapes[key].code;
                        selected_shape = shapes[key];
                        shapes[key].done = true;
                        completed = true;
                        break;
                    } else if (ing[i].food.toLowerCase().split(" ").some((r)=>shapes[key].keywords.map((shape)=>shape.toLowerCase()).includes(r)) && !shapes[key].done) {
                        // alert("in add shape for " + key);
                        shape += shapes[key].code;
                        selected_shape = shapes[key];
                        shapes[key].done = true;
                        completed = true;
                        break;
                    }
                }
                // determine movement from action
                let location = "";
                if (selected_shape && selected_shape.dim == "3D") // starting place + movement
                location = `displace(${i % 3 * .3},${Math.floor(i / 2) % 3 * .3 + .7},0);\n` + get_3d_movement(ins, selected_shape);
                else location = "";
                // apply movement
                while(shape.includes("%MOVEMENT%"))shape = shape.replace("%MOVEMENT%", location);
                code += "displace(" + 1 / ing[i].food.length + ");\n";
                code += shape;
            } // end loop
            // comment out to see json representation
            return code;
        }, peg$c1 = /^[^\n]/, peg$c2 = peg$classExpectation([
            "\n"
        ], true, false), peg$c3 = /^[\n]/, peg$c4 = peg$classExpectation([
            "\n"
        ], false, false), peg$c5 = function(d) {
            return d.join("").trim();
        }, peg$c6 = "	", peg$c7 = peg$literalExpectation("	", false), peg$c8 = function(n, s, f) {
            var type = "";
            if (f.includes("Merita")) type = "Merita";
            return {
                number: n,
                size: s,
                food: f,
                type: type
            };
        }, peg$c9 = function(i, fr) {
            return i + fr;
        }, peg$c10 = function(fr) {
            return fr;
        }, peg$c11 = "package", peg$c12 = peg$literalExpectation("package", false), peg$c13 = " (", peg$c14 = peg$literalExpectation(" (", false), peg$c15 = /^[0-9]/, peg$c16 = peg$classExpectation([
            [
                "0",
                "9"
            ]
        ], false, false), peg$c17 = " oz.)", peg$c18 = peg$literalExpectation(" oz.)", false), peg$c19 = function(s) {
            return s;
        }, peg$c20 = "tsp", peg$c21 = peg$literalExpectation("tsp", false), peg$c22 = "tbsp", peg$c23 = peg$literalExpectation("tbsp", false), peg$c24 = "cups", peg$c25 = peg$literalExpectation("cups", false), peg$c26 = "cup", peg$c27 = peg$literalExpectation("cup", false), peg$c28 = "teaspoon", peg$c29 = peg$literalExpectation("teaspoon", false), peg$c30 = ".", peg$c31 = peg$literalExpectation(".", false), peg$c32 = function(s) {
            return s;
        }, peg$c33 = function(text) {
            return text.trim();
        }, peg$c34 = /^[^.(;]/, peg$c35 = peg$classExpectation([
            ".",
            "(",
            ";"
        ], true, false), peg$c36 = /^[^.;]/, peg$c37 = peg$classExpectation([
            ".",
            ";"
        ], true, false), peg$c38 = /^[.;]/, peg$c39 = peg$classExpectation([
            ".",
            ";"
        ], false, false), peg$c40 = function(c, d, e) {
            return {
                instr: c.trim() + d.join("").trim(),
                end: e
            };
        }, peg$c41 = peg$otherExpectation("integer"), peg$c42 = function() {
            return parseInt(text(), 10);
        }, peg$c43 = /^[\xBC\xBD\xBE\u2150\u2151\u2152\u2153\u2154\u2155\u2156\u2157\u2158\u2159\u215A\u215B\u215C\u215D\u215E]/, peg$c44 = peg$classExpectation([
            "\xbc",
            "\xbd",
            "\xbe",
            "⅐",
            "⅑",
            "⅒",
            "⅓",
            "⅔",
            "⅕",
            "⅖",
            "⅗",
            "⅘",
            "⅙",
            "⅚",
            "⅛",
            "⅜",
            "⅝",
            "⅞"
        ], false, false), peg$c45 = function(char) {
            const normalized = char.normalize("NFKD");
            const operands = normalized.split("⁄");
            return operands[0] / operands[1];
        }, peg$c46 = "(", peg$c47 = peg$literalExpectation("(", false), peg$c48 = /^[a-zA-Z]/, peg$c49 = peg$classExpectation([
            [
                "a",
                "z"
            ],
            [
                "A",
                "Z"
            ]
        ], false, false), peg$c50 = ")", peg$c51 = peg$literalExpectation(")", false), peg$c52 = function(c, o) {
            return {
                type: "Output",
                count: c,
                content: o.join("").trim()
            };
        }, peg$c53 = /^[m,M]/, peg$c54 = peg$classExpectation([
            "m",
            ",",
            "M"
        ], false, false), peg$c55 = "akes", peg$c56 = peg$literalExpectation("akes", false), peg$c57 = /^[^.]/, peg$c58 = peg$classExpectation([
            "."
        ], true, false), peg$c59 = function(m, c, o) {
            return {
                type: "Output",
                count: c,
                modifiers: m,
                content: o.join("").trim()
            };
        }, peg$c60 = /^[t,T]/, peg$c61 = peg$classExpectation([
            "t",
            ",",
            "T"
        ], false, false), peg$c62 = "his recipe", peg$c63 = peg$literalExpectation("his recipe", false), peg$c64 = /^[s,S]/, peg$c65 = peg$classExpectation([
            "s",
            ",",
            "S"
        ], false, false), peg$c66 = "erves", peg$c67 = peg$literalExpectation("erves", false), peg$c68 = function(m, c) {
            return {
                type: "Output",
                count: c,
                modifiers: m,
                content: "people"
            };
        }, peg$c69 = "about", peg$c70 = peg$literalExpectation("about", false), peg$c71 = "around", peg$c72 = peg$literalExpectation("around", false), peg$c73 = function(a) {
            return a;
        }, peg$c74 = " or ", peg$c75 = peg$literalExpectation(" or ", false), peg$c76 = "-", peg$c77 = peg$literalExpectation("-", false), peg$c78 = function(l, h) {
            return {
                low: parseInt(l.join("")),
                high: parseInt(h.join(""))
            };
        }, peg$c79 = function(c) {
            return parseInt(c.join(""));
        }, peg$c80 = peg$otherExpectation("whitespace"), peg$c81 = /^[ \t\n\r]/, peg$c82 = peg$classExpectation([
            " ",
            "	",
            "\n",
            "\r"
        ], false, false), peg$c83 = /^[^\n\r]/, peg$c84 = peg$classExpectation([
            "\n",
            "\r"
        ], true, false), peg$c85 = "\n", peg$c86 = peg$literalExpectation("\n", false), peg$c87 = "\r", peg$c88 = peg$literalExpectation("\r", false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [
            {
                line: 1,
                column: 1
            }
        ], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
        if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
            return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
            return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description, location) {
            location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
            throw peg$buildStructuredError([
                peg$otherExpectation(description)
            ], input.substring(peg$savedPos, peg$currPos), location);
        }
        function error(message, location) {
            location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
            throw peg$buildSimpleError(message, location);
        }
        function peg$literalExpectation(text, ignoreCase) {
            return {
                type: "literal",
                text: text,
                ignoreCase: ignoreCase
            };
        }
        function peg$classExpectation(parts, inverted, ignoreCase) {
            return {
                type: "class",
                parts: parts,
                inverted: inverted,
                ignoreCase: ignoreCase
            };
        }
        function peg$anyExpectation() {
            return {
                type: "any"
            };
        }
        function peg$endExpectation() {
            return {
                type: "end"
            };
        }
        function peg$otherExpectation(description) {
            return {
                type: "other",
                description: description
            };
        }
        function peg$computePosDetails(pos) {
            var details = peg$posDetailsCache[pos], p;
            if (details) return details;
            else {
                p = pos - 1;
                while(!peg$posDetailsCache[p])p--;
                details = peg$posDetailsCache[p];
                details = {
                    line: details.line,
                    column: details.column
                };
                while(p < pos){
                    if (input.charCodeAt(p) === 10) {
                        details.line++;
                        details.column = 1;
                    } else details.column++;
                    p++;
                }
                peg$posDetailsCache[pos] = details;
                return details;
            }
        }
        function peg$computeLocation(startPos, endPos) {
            var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
            return {
                start: {
                    offset: startPos,
                    line: startPosDetails.line,
                    column: startPosDetails.column
                },
                end: {
                    offset: endPos,
                    line: endPosDetails.line,
                    column: endPosDetails.column
                }
            };
        }
        function peg$fail(expected) {
            if (peg$currPos < peg$maxFailPos) return;
            if (peg$currPos > peg$maxFailPos) {
                peg$maxFailPos = peg$currPos;
                peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected);
        }
        function peg$buildSimpleError(message, location) {
            return new peg$SyntaxError(message, null, null, location);
        }
        function peg$buildStructuredError(expected, found, location) {
            return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
        }
        function peg$parseProgram() {
            var s0, s1, s2, s3, s4, s5, s6;
            s0 = peg$currPos;
            s1 = peg$parseTitle();
            if (s1 !== peg$FAILED) {
                s2 = peg$parsenewline();
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseIngredientBlock();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parsenewline();
                        if (s4 !== peg$FAILED) {
                            s5 = peg$parseInstructionBlock();
                            if (s5 !== peg$FAILED) {
                                s6 = peg$parse_();
                                if (s6 === peg$FAILED) s6 = null;
                                if (s6 !== peg$FAILED) {
                                    peg$savedPos = s0;
                                    s1 = peg$c0(s1, s3, s5);
                                    s0 = s1;
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            return s0;
        }
        function peg$parseTitle() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = [];
            if (peg$c1.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c2);
            }
            if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                s1.push(s2);
                if (peg$c1.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c2);
                }
            }
            else s1 = peg$FAILED;
            if (s1 !== peg$FAILED) {
                if (peg$c3.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c4);
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c5(s1);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            return s0;
        }
        function peg$parseIngredientBlock() {
            var s0, s1;
            s0 = [];
            s1 = peg$parseIngredient();
            if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
                s0.push(s1);
                s1 = peg$parseIngredient();
            }
            else s0 = peg$FAILED;
            return s0;
        }
        function peg$parseIngredient() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = peg$parseNumber();
            if (s1 === peg$FAILED) s1 = null;
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 9) {
                    s2 = peg$c6;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c7);
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parseSize();
                    if (s3 === peg$FAILED) s3 = null;
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parseFood();
                        if (s4 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c8(s1, s3, s4);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            return s0;
        }
        function peg$parseNumber() {
            var s0, s1, s2;
            s0 = peg$currPos;
            s1 = peg$parseInteger();
            if (s1 !== peg$FAILED) {
                s2 = peg$parseFraction();
                if (s2 === peg$FAILED) s2 = null;
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c9(s1, s2);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseFraction();
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c10(s1);
                }
                s0 = s1;
            }
            return s0;
        }
        function peg$parseSize() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 7) === peg$c11) {
                s1 = peg$c11;
                peg$currPos += 7;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c12);
            }
            if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 2) === peg$c13) {
                    s2 = peg$c13;
                    peg$currPos += 2;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c14);
                }
                if (s2 !== peg$FAILED) {
                    if (peg$c15.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c16);
                    }
                    if (s3 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 5) === peg$c17) {
                            s4 = peg$c17;
                            peg$currPos += 5;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c18);
                        }
                        if (s4 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c19(s1);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 3) === peg$c20) {
                    s1 = peg$c20;
                    peg$currPos += 3;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c21);
                }
                if (s1 === peg$FAILED) {
                    if (input.substr(peg$currPos, 4) === peg$c22) {
                        s1 = peg$c22;
                        peg$currPos += 4;
                    } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c23);
                    }
                    if (s1 === peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c24) {
                            s1 = peg$c24;
                            peg$currPos += 4;
                        } else {
                            s1 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c25);
                        }
                        if (s1 === peg$FAILED) {
                            if (input.substr(peg$currPos, 3) === peg$c26) {
                                s1 = peg$c26;
                                peg$currPos += 3;
                            } else {
                                s1 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$c27);
                            }
                            if (s1 === peg$FAILED) {
                                if (input.substr(peg$currPos, 8) === peg$c28) {
                                    s1 = peg$c28;
                                    peg$currPos += 8;
                                } else {
                                    s1 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c29);
                                }
                                if (s1 === peg$FAILED) {
                                    if (input.substr(peg$currPos, 7) === peg$c11) {
                                        s1 = peg$c11;
                                        peg$currPos += 7;
                                    } else {
                                        s1 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$c12);
                                    }
                                }
                            }
                        }
                    }
                }
                if (s1 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                        s2 = peg$c30;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c31);
                    }
                    if (s2 === peg$FAILED) s2 = null;
                    if (s2 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c32(s1);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            return s0;
        }
        function peg$parseFood() {
            var s0, s1, s2, s3;
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = [];
            s3 = peg$parsechar();
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsechar();
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) s1 = input.substring(s1, peg$currPos);
            else s1 = s2;
            if (s1 !== peg$FAILED) {
                s2 = peg$parsenewline();
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c33(s1);
                    s0 = s1;
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            return s0;
        }
        function peg$parseInstructionBlock() {
            var s0, s1;
            s0 = [];
            s1 = peg$parseInstruction();
            if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
                s0.push(s1);
                s1 = peg$parseInstruction();
            }
            else s0 = peg$FAILED;
            return s0;
        }
        function peg$parseInstruction() {
            var s0, s1, s2, s3;
            s0 = peg$parseOutput();
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (peg$c34.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c35);
                }
                if (s1 !== peg$FAILED) {
                    s2 = [];
                    if (peg$c36.test(input.charAt(peg$currPos))) {
                        s3 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c37);
                    }
                    if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                        s2.push(s3);
                        if (peg$c36.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c37);
                        }
                    }
                    else s2 = peg$FAILED;
                    if (s2 !== peg$FAILED) {
                        if (peg$c38.test(input.charAt(peg$currPos))) {
                            s3 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c39);
                        }
                        if (s3 !== peg$FAILED) {
                            peg$savedPos = s0;
                            s1 = peg$c40(s1, s2, s3);
                            s0 = s1;
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            return s0;
        }
        function peg$parseInteger() {
            var s0, s1, s2;
            peg$silentFails++;
            s0 = peg$currPos;
            s1 = [];
            if (peg$c15.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c16);
            }
            if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                s1.push(s2);
                if (peg$c15.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c16);
                }
            }
            else s1 = peg$FAILED;
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c42();
            }
            s0 = s1;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c41);
            }
            return s0;
        }
        function peg$parseFraction() {
            var s0, s1;
            s0 = peg$currPos;
            if (peg$c43.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c44);
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c45(s1);
            }
            s0 = s1;
            return s0;
        }
        function peg$parseOutput() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 === peg$FAILED) s1 = null;
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                    s2 = peg$c46;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c47);
                }
                if (s2 !== peg$FAILED) {
                    s3 = peg$parsenum_range();
                    if (s3 !== peg$FAILED) {
                        s4 = peg$parse_();
                        if (s4 !== peg$FAILED) {
                            s5 = [];
                            if (peg$c48.test(input.charAt(peg$currPos))) {
                                s6 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s6 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$c49);
                            }
                            if (s6 !== peg$FAILED) while(s6 !== peg$FAILED){
                                s5.push(s6);
                                if (peg$c48.test(input.charAt(peg$currPos))) {
                                    s6 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c49);
                                }
                            }
                            else s5 = peg$FAILED;
                            if (s5 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 46) {
                                    s6 = peg$c30;
                                    peg$currPos++;
                                } else {
                                    s6 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c31);
                                }
                                if (s6 === peg$FAILED) s6 = null;
                                if (s6 !== peg$FAILED) {
                                    s7 = peg$parse_();
                                    if (s7 === peg$FAILED) s7 = null;
                                    if (s7 !== peg$FAILED) {
                                        if (input.charCodeAt(peg$currPos) === 41) {
                                            s8 = peg$c50;
                                            peg$currPos++;
                                        } else {
                                            s8 = peg$FAILED;
                                            if (peg$silentFails === 0) peg$fail(peg$c51);
                                        }
                                        if (s8 !== peg$FAILED) {
                                            peg$savedPos = s0;
                                            s1 = peg$c52(s3, s5);
                                            s0 = s1;
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parse_();
                if (s1 === peg$FAILED) s1 = null;
                if (s1 !== peg$FAILED) {
                    if (peg$c53.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c54);
                    }
                    if (s2 !== peg$FAILED) {
                        if (input.substr(peg$currPos, 4) === peg$c55) {
                            s3 = peg$c55;
                            peg$currPos += 4;
                        } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c56);
                        }
                        if (s3 !== peg$FAILED) {
                            s4 = peg$parse_();
                            if (s4 === peg$FAILED) s4 = null;
                            if (s4 !== peg$FAILED) {
                                s5 = peg$parseapprox();
                                if (s5 === peg$FAILED) s5 = null;
                                if (s5 !== peg$FAILED) {
                                    s6 = peg$parse_();
                                    if (s6 === peg$FAILED) s6 = null;
                                    if (s6 !== peg$FAILED) {
                                        s7 = peg$parsenum_range();
                                        if (s7 !== peg$FAILED) {
                                            s8 = peg$parse_();
                                            if (s8 !== peg$FAILED) {
                                                s9 = [];
                                                if (peg$c57.test(input.charAt(peg$currPos))) {
                                                    s10 = input.charAt(peg$currPos);
                                                    peg$currPos++;
                                                } else {
                                                    s10 = peg$FAILED;
                                                    if (peg$silentFails === 0) peg$fail(peg$c58);
                                                }
                                                if (s10 !== peg$FAILED) while(s10 !== peg$FAILED){
                                                    s9.push(s10);
                                                    if (peg$c57.test(input.charAt(peg$currPos))) {
                                                        s10 = input.charAt(peg$currPos);
                                                        peg$currPos++;
                                                    } else {
                                                        s10 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$c58);
                                                    }
                                                }
                                                else s9 = peg$FAILED;
                                                if (s9 !== peg$FAILED) {
                                                    if (input.charCodeAt(peg$currPos) === 46) {
                                                        s10 = peg$c30;
                                                        peg$currPos++;
                                                    } else {
                                                        s10 = peg$FAILED;
                                                        if (peg$silentFails === 0) peg$fail(peg$c31);
                                                    }
                                                    if (s10 !== peg$FAILED) {
                                                        s11 = peg$parse_();
                                                        if (s11 === peg$FAILED) s11 = null;
                                                        if (s11 !== peg$FAILED) {
                                                            peg$savedPos = s0;
                                                            s1 = peg$c59(s5, s7, s9);
                                                            s0 = s1;
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
                if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parse_();
                    if (s1 === peg$FAILED) s1 = null;
                    if (s1 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 40) {
                            s2 = peg$c46;
                            peg$currPos++;
                        } else {
                            s2 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c47);
                        }
                        if (s2 === peg$FAILED) s2 = null;
                        if (s2 !== peg$FAILED) {
                            s3 = peg$currPos;
                            if (peg$c60.test(input.charAt(peg$currPos))) {
                                s4 = input.charAt(peg$currPos);
                                peg$currPos++;
                            } else {
                                s4 = peg$FAILED;
                                if (peg$silentFails === 0) peg$fail(peg$c61);
                            }
                            if (s4 !== peg$FAILED) {
                                if (input.substr(peg$currPos, 10) === peg$c62) {
                                    s5 = peg$c62;
                                    peg$currPos += 10;
                                } else {
                                    s5 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c63);
                                }
                                if (s5 !== peg$FAILED) {
                                    s6 = peg$parse_();
                                    if (s6 === peg$FAILED) s6 = null;
                                    if (s6 !== peg$FAILED) {
                                        s4 = [
                                            s4,
                                            s5,
                                            s6
                                        ];
                                        s3 = s4;
                                    } else {
                                        peg$currPos = s3;
                                        s3 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s3;
                                    s3 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s3;
                                s3 = peg$FAILED;
                            }
                            if (s3 === peg$FAILED) s3 = null;
                            if (s3 !== peg$FAILED) {
                                if (peg$c64.test(input.charAt(peg$currPos))) {
                                    s4 = input.charAt(peg$currPos);
                                    peg$currPos++;
                                } else {
                                    s4 = peg$FAILED;
                                    if (peg$silentFails === 0) peg$fail(peg$c65);
                                }
                                if (s4 !== peg$FAILED) {
                                    if (input.substr(peg$currPos, 5) === peg$c66) {
                                        s5 = peg$c66;
                                        peg$currPos += 5;
                                    } else {
                                        s5 = peg$FAILED;
                                        if (peg$silentFails === 0) peg$fail(peg$c67);
                                    }
                                    if (s5 !== peg$FAILED) {
                                        s6 = peg$parse_();
                                        if (s6 === peg$FAILED) s6 = null;
                                        if (s6 !== peg$FAILED) {
                                            s7 = peg$parseapprox();
                                            if (s7 === peg$FAILED) s7 = null;
                                            if (s7 !== peg$FAILED) {
                                                s8 = peg$parse_();
                                                if (s8 === peg$FAILED) s8 = null;
                                                if (s8 !== peg$FAILED) {
                                                    s9 = peg$parsenum_range();
                                                    if (s9 !== peg$FAILED) {
                                                        if (input.charCodeAt(peg$currPos) === 46) {
                                                            s10 = peg$c30;
                                                            peg$currPos++;
                                                        } else {
                                                            s10 = peg$FAILED;
                                                            if (peg$silentFails === 0) peg$fail(peg$c31);
                                                        }
                                                        if (s10 === peg$FAILED) s10 = null;
                                                        if (s10 !== peg$FAILED) {
                                                            if (input.charCodeAt(peg$currPos) === 41) {
                                                                s11 = peg$c50;
                                                                peg$currPos++;
                                                            } else {
                                                                s11 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$c51);
                                                            }
                                                            if (s11 === peg$FAILED) s11 = null;
                                                            if (s11 !== peg$FAILED) {
                                                                s12 = peg$parse_();
                                                                if (s12 === peg$FAILED) s12 = null;
                                                                if (s12 !== peg$FAILED) {
                                                                    peg$savedPos = s0;
                                                                    s1 = peg$c68(s7, s9);
                                                                    s0 = s1;
                                                                } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$FAILED;
                                                                }
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                }
            }
            return s0;
        }
        function peg$parseapprox() {
            var s0, s1;
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 5) === peg$c69) {
                s1 = peg$c69;
                peg$currPos += 5;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c70);
            }
            if (s1 === peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c71) {
                    s1 = peg$c71;
                    peg$currPos += 6;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c72);
                }
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c73(s1);
            }
            s0 = s1;
            return s0;
        }
        function peg$parsenum_range() {
            var s0, s1, s2, s3, s4;
            s0 = peg$currPos;
            s1 = [];
            if (peg$c15.test(input.charAt(peg$currPos))) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c16);
            }
            if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                s1.push(s2);
                if (peg$c15.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c16);
                }
            }
            else s1 = peg$FAILED;
            if (s1 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c74) {
                    s2 = peg$c74;
                    peg$currPos += 4;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c75);
                }
                if (s2 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                        s2 = peg$c76;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c77);
                    }
                }
                if (s2 !== peg$FAILED) {
                    s3 = [];
                    if (peg$c15.test(input.charAt(peg$currPos))) {
                        s4 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c16);
                    }
                    if (s4 !== peg$FAILED) while(s4 !== peg$FAILED){
                        s3.push(s4);
                        if (peg$c15.test(input.charAt(peg$currPos))) {
                            s4 = input.charAt(peg$currPos);
                            peg$currPos++;
                        } else {
                            s4 = peg$FAILED;
                            if (peg$silentFails === 0) peg$fail(peg$c16);
                        }
                    }
                    else s3 = peg$FAILED;
                    if (s3 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c78(s1, s3);
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = [];
                if (peg$c15.test(input.charAt(peg$currPos))) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c16);
                }
                if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
                    s1.push(s2);
                    if (peg$c15.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c16);
                    }
                }
                else s1 = peg$FAILED;
                if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c79(s1);
                }
                s0 = s1;
            }
            return s0;
        }
        function peg$parse_() {
            var s0, s1;
            peg$silentFails++;
            s0 = [];
            if (peg$c81.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c82);
            }
            if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
                s0.push(s1);
                if (peg$c81.test(input.charAt(peg$currPos))) {
                    s1 = input.charAt(peg$currPos);
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c82);
                }
            }
            else s0 = peg$FAILED;
            peg$silentFails--;
            if (s0 === peg$FAILED) {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c80);
            }
            return s0;
        }
        function peg$parsechar() {
            var s0;
            if (peg$c83.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c84);
            }
            return s0;
        }
        function peg$parsenewline() {
            var s0, s1, s2;
            if (input.charCodeAt(peg$currPos) === 10) {
                s0 = peg$c85;
                peg$currPos++;
            } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$c86);
            }
            if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 13) {
                    s1 = peg$c87;
                    peg$currPos++;
                } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$c88);
                }
                if (s1 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 10) {
                        s2 = peg$c85;
                        peg$currPos++;
                    } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$c86);
                    }
                    if (s2 === peg$FAILED) s2 = null;
                    if (s2 !== peg$FAILED) {
                        s1 = [
                            s1,
                            s2
                        ];
                        s0 = s1;
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            }
            return s0;
        }
        const setup = `
        let s = getSpace();
        let noiseScale = 340;
        // setGeometryQuality(10); 
        // setStepSize(.99);
        // setMaxIterations(50);

        // SQUARES
    let s_size = 0.8
    let size_sq = vec3(s_size)
    let noiseScale_sq = 340;
    let s_sq = getSpace();
    let n1_sq = noise(s_sq*10);
    let n2_sq = noise(s_sq*10+vec3(0,0,time));        
    let n3_sq = noise(s_sq*2+vec3(0,0,time));
    let n4_sq = noise(s_sq*2+vec3(0,0,time) + noise(s_sq*2+vec3(0,0,time)));
    let n5_sq = noise(s_sq*4+time);
    let wave = sin(s_sq.y*100+time+400);
    let y_sq = 1 * noise((noiseScale_sq -350) * s_sq) + 1.9;
    let n_sq = 2.5 * noise(noiseScale_sq -30 * s_sq + time) + .5;
    let p_sq = .5 * noise((noiseScale_sq -350) * s_sq) + 1.5;
    let m_sq = .3 * noise((noiseScale_sq -380) * s_sq) + .5;

    //row1
    displace(0,0,1)
    //olive gradient
    displace(-s_size,s_size*2,0);
    color(0.25,0.6*s_sq.x,0.03*s_sq.y);
    box(size_sq);

    //olive skin
    reset();
    displace(0,0,1)
    displace(0,s_size*2,0);
    color(.03*m_sq,.05*m_sq,0);
    box(size_sq);

    //pink lumpy spread
    reset();
    displace(0,0,1)
    displace(s_size,s_size*2,0);
    color(25*y_sq,3*n_sq*y_sq,1.5*n_sq);
    box(size_sq);

    //row2

    //tomato cherry
    reset();
    displace(0,0,1)
    displace(-s_size,s_size,0);
    color(.4*p_sq,.28*p_sq,.04*p_sq);
    color(3*y_sq,0.04*y_sq,0.03);
    //color(1.9*p_sq,0.16*y_sq,0.03*p_sq);
    box(size_sq);

    //pink shrimp
    reset();
    displace(0,0,1)
    displace(0,s_size,0);
    color(vec3(abs(n2_sq)*2)+normal*.3+vec3(25,1,0));
    box(size_sq);

    //yellow corn
    reset();
    displace(0,0,1)
    displace(s_size,s_size,0);
    color(9*y_sq+m_sq,1*y_sq+m_sq,0);
    box(size_sq);

    //row3

    //olive skin
    reset();
    displace(0,0,1)
    displace(-s_size,0,0);
    color(.4*p_sq,.28*p_sq,.04*p_sq);
    box(size_sq);

    //yellow yolk twirl
    reset();
    displace(0,0,1)
    function twirl(pn, tm) {
        let r = length(vec2(pn.x, pn.y));
        let th = atan(pn.x, pn.y);
        let r2 = 1;
        let f = 3; // # petals
        let amp = .06;
        let r3 = r2 + amp * sin(f * th + tm);
        let v = pn.z;
        let v2 = v + amp*cos(f * th - tm);
        let d = sqrt(v2 * v2 + r3 * r3) - 0.4;
    	return [d * 0.28, v2, r3];
    }

    let rad_sq = length(s_sq);
    let ds_sq = twirl(s_sq, time);
    color(3,nsin(33*ds_sq[2]),0);
    box(size_sq);

    //salmon spread
    reset();
    displace(0,0,1)
    displace(s_size,0,0);
    color(1.9*p_sq,0.09*y_sq,0.03*p_sq);
    box(size_sq);

     
    //row4

    //green garnish
    reset();
    displace(0,0,1)
    displace(-s_size,-s_size,0);
    color(0,0.05*n_sq,0)
    box(size_sq);

    //merita enrich bread
    reset();
    displace(0,0,1)
    displace(0,-s_size,0);
    color(16*m_sq,15*m_sq,8*m_sq);
    box(size_sq);

    //anchovie
    reset();
    displace(0,0,1)
    displace(s_size,-s_size,0);
    color(.28*m_sq*wave,.06*m_sq*wave,.002);
    box(size_sq);


      
        // color behaviors
        let w_sugar = noise (s*80); 
        let n_cornstarch = 2.5 * noise(noiseScale * s + time) + 1.5;
        let o_range = .5 * noise((noiseScale -350) * s + time) +  1.2;
        let r_hotbrown = 1.9 * noise((noiseScale -350) * s) + 1;
        let p_fudge = .5 * noise((noiseScale -350) * s) + 1.5;
        let y_red = 1 * noise((noiseScale -350) * s) + 1.9;
        let i_silver = noise(s*0.3+vec3(time,0,0));
      `;
        const get_3d_movement = (ins, selected_shape)=>{
            for(let k = 0; k < ins.length; k++){
                // match ingredient to that instruction
                if (selected_shape != undefined && ins[k].instr != undefined && selected_shape.keywords.some((v)=>ins[k].instr.toLowerCase().includes(v))) // find movement in that instruction
                for (const [key, value] of Object.entries(movements)){
                    if (ins[k].instr.toLowerCase().includes(key)) return value;
                }
            }
            return "";
        };
        const color_set = [
            "vec3(.45*i_silver,.45*i_silver,.45*i_silver)",
            "vec3(0.003,0.008,0.005)",
            "vec3(130*n_cornstarch,14*n_cornstarch,1.4*n_cornstarch)",
            "vec3(0.7*y_red,0.04*y_red,0.02*y_red)",
            "vec3(2,.7,0.1)",
            "vec3(0.48*p_fudge,0.1*p_fudge,0*p_fudge)",
            "vec3(0.28,0.6,0.35)",
            "vec3(80*w_sugar,90*w_sugar,8*w_sugar)",
            "vec3(18,1,0.1)",
            "vec3(1,0.3,0)",
            "vec3(0.028,0.06,0.035)",
            "vec3(120*o_range,0.30*o_range,0*o_range)",
            "vec3(0.05*r_hotbrown,0.009*r_hotbrown,0)",
            "vec3(2.8,0.08,0.03)" //outstanding red
        ];
        const food_colors = {
            "sugar": "vec3(80*w,90*w,8*w)",
            "cornstarch": "vec3(130*n_cornstarch,14*n_cornstarch,1.4*n_cornstarch);",
            "water": "vec3(0.28,0.6,0.35)",
            "orange juice": "vec3(0.175,0.2,0.4)",
            "salt": "vec3(34,0.5,0.7)",
            "egg": "vec3(5, 0.67, 0)",
            "orange": "vec3(120*o_range,0.30*o_range,0*o_range)",
            "lemon juice": "vec3(.7, .9, 0)",
            "butter": "vec3(0.1, 0.1, 0.8)"
        };
        const movements = {
            "toast": "displace(0,sin(time)/4,0);",
            "blend": "blend(abs(sin(time))/2 + 1/2);",
            "roll": "displace(sin(time)/2,cos(time)/2,0);",
            "trim": `
        union();
        color(0.1,0.1,cos(time));
        rotateY(time);
        torus(0.5,0.2);
        difference();
        displace(.5,0,0);
        box(.3,.25,.15);
        `,
            "wrap": "displace(sin(time)/2,cos(time)/2,0);",
            "place": "displace(0,sin(time),0);",
            // "mix": "displace(sin(time)/%x%,cos(time)/%y%,0);",
            // "stir": "displace(sin(time)/%x%,cos(time)/%y%,0);",
            // "add": "displace(sin(time)/%x%,cos(time)/%y%,0);",
            // "cool": "displace(sin(time)/%x%,cos(time)/%y%,0);",
            "return": "reset();"
        };
        const shapes = {};
        shapes["tomato"] = {
            dim: "3D",
            code: `
          reset();
      
          let bpm_max = 256;
          let bpm = 128;
          let bpm_normalized = bpm/bpm_max;
          let arrangement_tom = [.5,.2];  
          let p_tomatoes={
            size:.6,
            scale:2,
            noise:0.6,
          };
          
          let apple = shape((p,newPos, newAngle,movingData) => { 
            //base
            let s = getSpace(); 
            let rad = p.size*p.scale;
            let adjustedSize  =  vec3(1,0.96, 1);
          setSpace(s * adjustedSize); 
            
            let yPos = p.size*p.scale*adjustedSize.y;
            displace(0,yPos, 0); // pivot around bottom

            displace(0,p.size*-2,0); // push to base xyz
            displace(newPos); //now finally move where user wants
            let yAngle = (1-newAngle.y )* 360  ;
          rotateX((time+newAngle.y*10)*100*PI/180); 
          rotateY((time+newAngle.y*10)*50*PI/180); 
            rotateZ(yAngle*PI/180); 
            
            
            //color Main
            let n =1 * noise( s*6.8 )*0.2;
            n = clamp(n,0,0.8);
            let red  =vec3(0.6,0.04,0.01); 
            
            let offset = vec3(-0.3,-0.6,-0.3);
            red+=offset*movingData;
            color(red); 
            sphere(rad );  
            displace(0,p.size*3*yPos,0); // push to base xyz
            difference();
            box(rad,rad,rad);
          
            mixGeo(0.29);
            
            displace(0,rad*-1.5,.02*rad);   
            let w = 1.8; 
            sphere(rad*.8);

            union();
            
            
            //stem
            
            displace(rad*-0.05,rad*-0.8,-.01*rad); 
            let pieceDist = 0.3; 
            
              
          let stems =4; 
            for(let i=0;i<stems;i++){
              let col = i%2 ? vec3(0,1,0 ) : vec3(1,0,1);

              let t = 1;
              
              let maxPos = 0.06+ movingData*0.2;
              let timeMult = 6;
              let pos1 =vec3(sin(i/stems)*sin(time*timeMult)*maxPos*(i-1)*rad,rad*pieceDist*(i-1),0);
              let pos2 = vec3(sin(i/stems )*sin(time*timeMult)*maxPos*(i+1)*rad,rad*pieceDist*i,0);
              let stemColor = vec3(0,0.3-0.3 *(stems-i)/stems,0.01);  ;
              
            let stemColorHighlited  =vec3(0.8,-0.3,0.01);  
              stemColor+=stemColorHighlited*movingData;
              color(stemColor);
              let thickness = rad*0.05;
              thickness *=0.8+i*0.08+movingData;
              color(0, .3, 0);
              line(pos1, pos2, thickness); 
              color(0, .1, 0);
              cylinder(.027, .03);
            };

          });  

          lightDirection(1,-1,1);
          shine(0.8);
          let apples = arrangement_tom.length; 
          for(let i=0;i<apples;i++){
            let perc = i/apples;
            let pos = vec3(0);
            let angle = vec3(0,perc,0);
            let rad = 0.3;
            let s = arrangement_tom[i];
            let percOffset = time*60*bpm_normalized;
            let percNew = (perc*360+percOffset);
            pos.x = sin(percNew*PI/180);
            
            pos.y = cos(percNew*PI/180); 
            pos.y+=rad+1.24;
            pos*=rad;
            
            let min = -0.2;
            let max = 0.1;
            p_tomatoes.scale = 0.35;
            p_tomatoes.scale+=s*0.1;
            s*=max;
            pos.x+=sin(percNew*PI/180)*s;
            pos.y+=cos(percNew*PI/180)*s;
              
            displace(pos);
            apple(p_tomatoes,pos,angle,arrangement_tom[i]);
            reset();
          }; 
        `,
            keywords: [
                "tomato",
                "tomatoes"
            ]
        };
        shapes["hash"] = {
            dim: "3D",
            code: `
          reset();
      
          %MOVEMENT%
          let scale_hash = 2.0;
          let s_hash = getSpace();
          let n_hash = 0.1*noise(scale_hash * s_hash + time);
          let noiseScale_hash = 50;
          let t_hash = getSpace();
          let h_hash = 1.9 * noise(noiseScale_hash * t_hash + time) + .75;

          color(2*h_hash,0.4*h_hash,0.1*h_hash);
          cylinder(0.9, 0.1 + n_hash);
        `,
            keywords: [
                "hash"
            ]
        };
        shapes["shrimp"] = {
            dim: "3D",
            code: `
          reset();
      
    		  let s_shrimp = getSpace ();
          let noiseScale_shrimp = 340;
          let y_shrimp = 1 * noise((noiseScale_shrimp -350) * s_shrimp) + 1.9;
          let n_shrimp = 2.5 * noise(noiseScale_shrimp -30 * s_shrimp + time) + .5;
          let p_shrimp = .5 * noise((noiseScale_shrimp -350) * s_shrimp) + 1.5;

      		displace(-.5,-.3,0);
    //      %MOVEMENT%

          //salmon spread
          color(1.9*p_shrimp,0.09*y_shrimp,0.03*p_shrimp);


          let shrimp = shape (()=> {
            
          const ang = 2*nsin(0.3);
          cappedTorus(vec2(sin(ang),cos(ang)),0.5,0.15);
          blend(.2);
          displace(0.35,0.3,0);
          sphere(.2);
          blend(.3);
          displace(-0.3,0,0,);
          sphere(.15);

          });

          let shrimpTail = shape (()=> {

            let s = getSpace();
                  
            rotateX(-30);
            displace(.05,s.y*.7,0.15);
            sphere(.14);
            blend(.3);
            reset();
        
            rotateX(30);
            displace(.05,s.y*.7,0.15);
            sphere(.14);
            
          });

          shrimp();
          reset();
      
      		displace(-.5,-.3,0);
    //      %MOVEMENT%

          displace(-0.49,0,0);
          rotateX(14);
          rotateY(4);
          shrimpTail();

          reset();
      
      		displace(-.5,-.3,0);
    //      %MOVEMENT%

          color(0,0,0);
          displace(0.6,0.2,.1);
          sphere(.05);
          reset();
      

      		displace(-.5,-.3,0);
    //      %MOVEMENT%

          displace(0.6,0.2,-.11);
          sphere(.05);

        `,
            keywords: [
                "shrimp"
            ]
        };
        shapes["olive"] = {
            dim: "3D",
            code: `
          reset();
          color(0,0.3,0);
          let scale_olive = 3;
          let n_olive = 0.1*noise(scale_olive * getSpace() + time);
          sphere(0.35 + n_olive);

          mirrorX();
          color(0.40,0.8,0.30);
          torus(.5,abs(sin(time))/32);

          color(n_olive,n_olive,n_olive);
          displace(cos(time),-0.2,cos(time));
          sphere(0.2);

        `,
            keywords: [
                "olive",
                "olives"
            ]
        };
        shapes["bread"] = {
            dim: "3D",
            code: `
        reset();
        union();
        %MOVEMENT%
        color(0.7,0.5,0.3);
        box(0.28, 0.03, 0.28);
        mirrorX();
        displace(0.15,0,0.18);
        cylinder(0.18, 0.03);

        reset();
        %MOVEMENT%
        let t = getSpace();
        let h= 0.5 * noise(noiseScale * t + time) + 0.5;

        color(1*h,0.4*h,0.1*h);
        box(0.3, 0.03, 0.3);

        mirrorX();
        displace(0.15,0,0.18);
        cylinder(0.2, 0.03);
        reset();
        `,
            keywords: [
                "bread",
                "merita"
            ],
            type: "Merita"
        };
        shapes["torte"] = {
            dim: "3D",
            code: `
        union;
        rotateZ(sin(time) / 3);
        rotateX(sin(time) * 2);
        displace(0,0,cos(time) / 4);

        let torte_scale = 2.0;
        let torte_s = getSpace();
        let torte_n = 0.2*noise(torte_scale * torte_s + time);
        let torte_noiseScale = 10;
        let torte_t = getSpace();
        let torte_h = 1.9 * noise(torte_noiseScale * torte_t + time) + .75;

        color(.38*torte_h,.1*torte_h,cos(time)*torte_h);
        rotateY(time);

        torus(.5,.2);
        difference();
        displace(.5,0,0);
        box(.3,.25,.15);

        color(.3,.1,0);
        union();
        displace(-.5,-.16,0);
        cylinder(.69,.1);
        difference();
        cylinder(.33,.2);
        displace(.5,0,0);
        box(.3,.25,.15);
      `,
            keywords: [
                "torte",
                "yolk"
            ]
        };
        shapes["pickles"] = {
            dim: "3D",
            code: `
        reset();
        union();

        let freq = 4
        let n = noise(s * freq + time) * 0.05;
        n = noise(vec3(n+time*0,n+0.1-time*0.1,n+0.5-time*0.1)*2.1)*0.01

        displace(-.5,-.7,0);

        color(n,n*7.5,0);
    //    mirrorX();
        blend(0.2);
        displace(.2,-0.25);
        sphere(0.15+n*2);
        displace(0,.1,.0);
        sphere(0.15+n*2);
        displace(0,.2,0.);
        sphere(0.15+n*2);
        displace(0,.2);
        sphere(0.15+n*2);
      `,
            keywords: [
                "pickle",
                "pickles",
                "dill"
            ]
        };
        shapes["dog"] = {
            dim: "3D",
            code: `
        reset();
        union();

        color(0.256,0,0);

        let halfCircle = shape(() => {  

          sphere(0.2);
          difference();
          displace(0,-.15,0);
          box(0.21,0.28,0.21);
        })

        let hat =(() => {
        
          halfCircle();
          blend(0.04);
          displace(0,0.23,0);
          sphere(0.02)
          displace(0,-0.08,0);
          torus(0.16,0.01);
        })

        %MOVEMENT%
        displace(0,0.1,0.4);
        hat();

        //nose
        reset();

        %MOVEMENT%
        color(0,0,0);
        displace(0.02,-.1,-.2);
        sphere(0.050);

        //eyes
        reset();

        %MOVEMENT%
        mirrorX();
        displace(0.15,0,0);
        sphere(0.05);

        //ears
        color(.94,.80,.40);
        displace(0.35,-0.3,0.3);
        sphere(0.2);

        //head
        reset();

        %MOVEMENT%
        blend(0.1);

        rotateX(PI/6);
        displace(0,0,0.50);
        sphere(0.48);
        blend(0.1);
        displace(0,-.28,-.4);
        sphere(0.20);

        reset();
        %MOVEMENT%
        displace(0,-0.7,0.3);


        function oscillate(x) {
          return sin(24*x)*0.5;
        }

        rotateY(time);

        let dog_n = toSpherical(getSpace());
        let dog_m = min(oscillate(dog_n.y),oscillate(dog_n.z));
        color(vec3(dog_m+0.5));
        cylinder(0.5,0.03);
      `,
            keywords: [
                "salt",
                "pepper"
            ]
        };
        shapes["kids"] = {
            dim: "2D",
            code: `
        let kids_x = 0;let kids_y = 0;
        let img1 = new Image();
        img1.src = 'img/boy_and_girl.png';

        setInterval(function() {
          let overlap = document.getElementById('2d_canvas');
          const ctx = overlap.getContext("2d");
          if (kids_x > overlap.width || kids_y > overlap.height) { 
            kids_x = 0;
            kids_y = 0;
          }
          if (kids_x % 100 == 0) 
            ctx.clearRect(0, 0, overlap.width, overlap.height);
          
          ctx.drawImage(img1, kids_x, kids_y, 295 * 2, 225 * 2);

          kids_x+=4;kids_y+=4;
        }, 200); 
      `,
            keywords: [
                "pimiento"
            ]
        };
        shapes["eggs"] = {
            dim: "2D",
            code: `
        let kids_x = 0;let kids_y = 0;
        let img1 = new Image();
        img1.src = 'img/devil_egg.png';

        setInterval(function() {
          let overlap = document.getElementById('2d_canvas');
          const ctx = overlap.getContext("2d");
          if (kids_x > overlap.width || kids_y > overlap.height) { 
            kids_x = 0;
            kids_y = 0;
          }
          if (kids_x % 100 == 0) 
            ctx.clearRect(0, 0, overlap.width, overlap.height);
          
          ctx.drawImage(img1, kids_x, kids_y, 295 * 2, 225 * 2);

          kids_x+=4;kids_y+=4;
        }, 200); 
      `,
            keywords: [
                "egg"
            ]
        };
        shapes["second_bread"] = {
            dim: "2D",
            code: `
        let img_dog = new Image();
        img_dog.src = 'img/merita_bread.png';

        setInterval(function() {
          let overlap = document.getElementById('2d_canvas');
          const ctx = overlap.getContext("2d");

    //      ctx.clearRect(0, 0, overlap.width, overlap.height);
          
          ctx.drawImage(img_dog, Math.floor(Math.random() * overlap.width), Math.floor(Math.random() * overlap.height), 1098, 615);
        }, 2000);
        `,
            keywords: [
                "bread",
                "merita"
            ],
            type: "Merita"
        };
        shapes["butter_family"] = {
            dim: "2D",
            code: `
        let img_meita = new Image();
        img_meita.src = 'img/merita_family.png';

        setInterval(function() {
          let overlap = document.getElementById('2d_canvas');
          const ctx = overlap.getContext("2d");

          ctx.clearRect(0, 0, overlap.width, overlap.height);
          
          ctx.drawImage(img_meita, Math.floor(Math.random() * overlap.width), Math.floor(Math.random() * overlap.height), 855, 619);
        }, 2100);
        `,
            keywords: [
                "butter",
                "milk"
            ]
        };
        shapes["second_salt"] = {
            dim: "2D",
            code: `
        let img_salt = new Image();
        img_salt.src = 'img/porcellain_dog.png';

        setInterval(function() {
          let overlap = document.getElementById('2d_canvas');
          const ctx = overlap.getContext("2d");

    //      ctx.clearRect(0, 0, overlap.width, overlap.height);
          
          ctx.drawImage(img_salt, Math.floor(Math.random() * overlap.width), Math.floor(Math.random() * overlap.height), 275, 429);
        }, 1900);
        `,
            keywords: [
                "salt",
                "pepper"
            ]
        };
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
        else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
            throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
        }
    }
    return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
    };
}();

//# sourceMappingURL=index.760f6671.js.map
